#ifndef SHADER_SOURCES_H
#define SHADER_SOURCES_H

// Embedded WGSL shader sources for WebGPU backend

static const char* SHADER_ADD = 
"@group(0) @binding(0) var<storage, read> input_a: array<f32>;\n"
"@group(0) @binding(1) var<storage, read> input_b: array<f32>;\n"
"@group(0) @binding(2) var<storage, read_write> output: array<f32>;\n"
"\n"
"@compute @workgroup_size(256)\n"
"fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n"
"    let idx = global_id.x;\n"
"    if (idx < arrayLength(&output)) {\n"
"        output[idx] = input_a[idx] + input_b[idx];\n"
"    }\n"
"}\n";

static const char* SHADER_SUB = 
"@group(0) @binding(0) var<storage, read> input_a: array<f32>;\n"
"@group(0) @binding(1) var<storage, read> input_b: array<f32>;\n"
"@group(0) @binding(2) var<storage, read_write> output: array<f32>;\n"
"\n"
"@compute @workgroup_size(256)\n"
"fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n"
"    let idx = global_id.x;\n"
"    if (idx < arrayLength(&output)) {\n"
"        output[idx] = input_a[idx] - input_b[idx];\n"
"    }\n"
"}\n";

static const char* SHADER_MUL = 
"@group(0) @binding(0) var<storage, read> input_a: array<f32>;\n"
"@group(0) @binding(1) var<storage, read> input_b: array<f32>;\n"
"@group(0) @binding(2) var<storage, read_write> output: array<f32>;\n"
"\n"
"@compute @workgroup_size(256)\n"
"fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n"
"    let idx = global_id.x;\n"
"    if (idx < arrayLength(&output)) {\n"
"        output[idx] = input_a[idx] * input_b[idx];\n"
"    }\n"
"}\n";

static const char* SHADER_RELU = 
"@group(0) @binding(0) var<storage, read> input: array<f32>;\n"
"@group(0) @binding(1) var<storage, read_write> output: array<f32>;\n"
"\n"
"@compute @workgroup_size(256)\n"
"fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n"
"    let idx = global_id.x;\n"
"    if (idx < arrayLength(&output)) {\n"
"        output[idx] = max(0.0, input[idx]);\n"
"    }\n"
"}\n";

static const char* SHADER_SIGMOID = 
"@group(0) @binding(0) var<storage, read> input: array<f32>;\n"
"@group(0) @binding(1) var<storage, read_write> output: array<f32>;\n"
"\n"
"@compute @workgroup_size(256)\n"
"fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n"
"    let idx = global_id.x;\n"
"    if (idx < arrayLength(&output)) {\n"
"        output[idx] = 1.0 / (1.0 + exp(-input[idx]));\n"
"    }\n"
"}\n";

static const char* SHADER_TANH = 
"@group(0) @binding(0) var<storage, read> input: array<f32>;\n"
"@group(0) @binding(1) var<storage, read_write> output: array<f32>;\n"
"\n"
"@compute @workgroup_size(256)\n"
"fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n"
"    let idx = global_id.x;\n"
"    if (idx < arrayLength(&output)) {\n"
"        output[idx] = tanh(input[idx]);\n"
"    }\n"
"}\n";

static const char* SHADER_MATMUL = 
"struct Dimensions {\n"
"    M: u32,\n"
"    K: u32,\n"
"    N: u32,\n"
"    pad: u32,\n"
"};\n"
"\n"
"@group(0) @binding(0) var<storage, read> matrix_a: array<f32>;\n"
"@group(0) @binding(1) var<storage, read> matrix_b: array<f32>;\n"
"@group(0) @binding(2) var<storage, read_write> matrix_c: array<f32>;\n"
"@group(0) @binding(3) var<uniform> dims: Dimensions;\n"
"\n"
"const TILE_SIZE: u32 = 16u;\n"
"\n"
"var<workgroup> tile_a: array<f32, 256>;\n"
"var<workgroup> tile_b: array<f32, 256>;\n"
"\n"
"@compute @workgroup_size(16, 16)\n"
"fn main(\n"
"    @builtin(global_invocation_id) global_id: vec3<u32>,\n"
"    @builtin(local_invocation_id) local_id: vec3<u32>,\n"
"    @builtin(workgroup_id) workgroup_id: vec3<u32>\n"
") {\n"
"    let row = global_id.y;\n"
"    let col = global_id.x;\n"
"    let local_row = local_id.y;\n"
"    let local_col = local_id.x;\n"
"    \n"
"    var sum: f32 = 0.0;\n"
"    \n"
"    let num_tiles = (dims.K + TILE_SIZE - 1u) / TILE_SIZE;\n"
"    for (var t: u32 = 0u; t < num_tiles; t = t + 1u) {\n"
"        let a_col = t * TILE_SIZE + local_col;\n"
"        if (row < dims.M && a_col < dims.K) {\n"
"            tile_a[local_row * TILE_SIZE + local_col] = matrix_a[row * dims.K + a_col];\n"
"        } else {\n"
"            tile_a[local_row * TILE_SIZE + local_col] = 0.0;\n"
"        }\n"
"        \n"
"        let b_row = t * TILE_SIZE + local_row;\n"
"        if (b_row < dims.K && col < dims.N) {\n"
"            tile_b[local_row * TILE_SIZE + local_col] = matrix_b[b_row * dims.N + col];\n"
"        } else {\n"
"            tile_b[local_row * TILE_SIZE + local_col] = 0.0;\n"
"        }\n"
"        \n"
"        workgroupBarrier();\n"
"        \n"
"        for (var k: u32 = 0u; k < TILE_SIZE; k = k + 1u) {\n"
"            sum = sum + tile_a[local_row * TILE_SIZE + k] * tile_b[k * TILE_SIZE + local_col];\n"
"        }\n"
"        \n"
"        workgroupBarrier();\n"
"    }\n"
"    \n"
"    if (row < dims.M && col < dims.N) {\n"
"        matrix_c[row * dims.N + col] = sum;\n"
"    }\n"
"}\n";

static const char* SHADER_SOFTMAX = 
"struct SoftmaxParams {\n"
"    size: u32,\n"
"    stride: u32,\n"
"    pad1: u32,\n"
"    pad2: u32,\n"
"};\n"
"\n"
"@group(0) @binding(0) var<storage, read> input: array<f32>;\n"
"@group(0) @binding(1) var<storage, read_write> output: array<f32>;\n"
"@group(0) @binding(2) var<uniform> params: SoftmaxParams;\n"
"\n"
"var<workgroup> shared_max: array<f32, 256>;\n"
"var<workgroup> shared_sum: array<f32, 256>;\n"
"\n"
"@compute @workgroup_size(256)\n"
"fn main(\n"
"    @builtin(global_invocation_id) global_id: vec3<u32>,\n"
"    @builtin(local_invocation_id) local_id: vec3<u32>,\n"
"    @builtin(workgroup_id) workgroup_id: vec3<u32>\n"
") {\n"
"    let batch_idx = workgroup_id.x;\n"
"    let local_idx = local_id.x;\n"
"    let offset = batch_idx * params.stride;\n"
"    \n"
"    var local_max: f32 = -3.402823466e+38;\n"
"    for (var i = local_idx; i < params.size; i = i + 256u) {\n"
"        local_max = max(local_max, input[offset + i]);\n"
"    }\n"
"    shared_max[local_idx] = local_max;\n"
"    workgroupBarrier();\n"
"    \n"
"    for (var s = 128u; s > 0u; s = s >> 1u) {\n"
"        if (local_idx < s) {\n"
"            shared_max[local_idx] = max(shared_max[local_idx], shared_max[local_idx + s]);\n"
"        }\n"
"        workgroupBarrier();\n"
"    }\n"
"    let max_val = shared_max[0];\n"
"    \n"
"    var local_sum: f32 = 0.0;\n"
"    for (var i = local_idx; i < params.size; i = i + 256u) {\n"
"        let exp_val = exp(input[offset + i] - max_val);\n"
"        output[offset + i] = exp_val;\n"
"        local_sum = local_sum + exp_val;\n"
"    }\n"
"    shared_sum[local_idx] = local_sum;\n"
"    workgroupBarrier();\n"
"    \n"
"    for (var s = 128u; s > 0u; s = s >> 1u) {\n"
"        if (local_idx < s) {\n"
"            shared_sum[local_idx] = shared_sum[local_idx] + shared_sum[local_idx + s];\n"
"        }\n"
"        workgroupBarrier();\n"
"    }\n"
"    let sum_val = shared_sum[0];\n"
"    \n"
"    for (var i = local_idx; i < params.size; i = i + 256u) {\n"
"        output[offset + i] = output[offset + i] / sum_val;\n"
"    }\n"
"}\n";

#endif // SHADER_SOURCES_H
